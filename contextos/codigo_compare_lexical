# Detector de Pl√°gio e Par√°frase

Este projeto implementa um sistema para **comparar textos** por duas abordagens complementares:  
- **L√©xica** ‚Äì an√°lise baseada em padr√µes de palavras (TF-IDF e n-gramas).  
- **Sem√¢ntica** ‚Äì an√°lise baseada no significado (embeddings com `sentence-transformers`).  

O objetivo √© combinar essas an√°lises para obter uma avalia√ß√£o robusta da similaridade textual, √∫til para detec√ß√£o de pl√°gio, identifica√ß√£o de par√°frases e compara√ß√£o de conte√∫dos de dom√≠nio p√∫blico.  

O projeto foi pensado para rodar **tanto localmente quanto via Docker**, garantindo que o ambiente seja reprodut√≠vel e que os resultados sejam consistentes.

---

import pytest
from sklearn.feature_extraction.text import TfidfVectorizer
from src.compare_lexical import compare_lexical


# üîπ Fixture para preparar um cen√°rio de teste consistente
# Cria um corpus pequeno, treina um TfidfVectorizer e gera:
# - tfidf_model: o modelo treinado
# - tfidf_matrix: matriz TF-IDF dos documentos
# - id_map: lista de dicion√°rios no formato esperado pela fun√ß√£o
@pytest.fixture
def tfidf_setup():
    corpus = [
        "Ol√° mundo de dados e privacidade",
        "Privacidade de dados pessoais e seguran√ßa",
        "Cinema brasileiro e pol√≠ticas culturais",
    ]
    tfidf_model = TfidfVectorizer()
    tfidf_matrix = tfidf_model.fit_transform(corpus)
    id_map = [{"uid": f"doc_{i}"} for i in range(len(corpus))]
    return corpus, tfidf_model, tfidf_matrix, id_map


# üîπ Testa se o ranking √© retornado corretamente
# Espera que o documento mais similar ao query seja o doc_1,
# e o segundo mais pr√≥ximo seja o doc_0
def test_compare_lexical_ranking_basic(tfidf_setup):
    _, tfidf_model, tfidf_matrix, id_map = tfidf_setup
    query = "privacidade e dados pessoais"
    result = compare_lexical(query, tfidf_model, tfidf_matrix, id_map, top_n=3)

    assert len(result) == 3
    assert result[0][0] == "doc_1"  # documento mais pr√≥ximo
    assert result[1][0] == "doc_0"  # segundo mais pr√≥ximo


# üîπ Testa comportamento com consulta vazia
# Espera que retorne lista vazia se o texto de entrada for vazio
def test_compare_lexical_empty_query(tfidf_setup):
    _, tfidf_model, tfidf_matrix, id_map = tfidf_setup
    assert compare_lexical("", tfidf_model, tfidf_matrix, id_map) == []


# üîπ Testa se respeita o limite definido pelo par√¢metro top_n
# Aqui top_n=1, ent√£o s√≥ deve retornar o documento mais similar
def test_compare_lexical_top_n_limit(tfidf_setup):
    _, tfidf_model, tfidf_matrix, id_map = tfidf_setup
    result = compare_lexical("dados pessoais e privacidade", tfidf_model, tfidf_matrix, id_map, top_n=1)
    assert len(result) == 1
